# -*- coding: utf-8 -*-
"""lr3-4.ipynb

Automatically generated by Colaboratory.

# Программирование (Python)
## 6 семестр, тема 1

### Лабораторная работа 2

Используя обучающий набор данных о пассажирах Титаника, находящийся в проекте (оригинал: https://www.kaggle.com/c/titanic/data), найдите ответы на следующие вопросы:

1. Какое количество мужчин и женщин ехало на параходе? Приведите два числа через пробел. __DONE__

2. Подсчитайте сколько пассажиров загрузилось на борт в различных портах? Приведите три числа через пробел.__DONE__

3. Посчитайте долю (процент) погибших на параходе (число и процент)? 

4. Какие доли составляли пассажиры первого, второго, третьего класса?

5. Вычислите коэффициент корреляции Пирсона между количеством супругов (SibSp) и количеством детей (Parch).

6. Выясните есть ли корреляция (вычислите коэффициент корреляции Пирсона) между:
- возрастом и параметром Survived;
- полом человека и параметром Survived;
- классом, в котором пассажир ехал, и параметром Survived.

7. Посчитайте средний возраст пассажиров и медиану, минимальный и максимальный возраст.
8. Посчитайте среднюю цену за билет и медиану, минимальная и максимальные цены.

9. Какое самое популярное мужское имя на корабле?
10. Какие самые популярные мужское и женские имена людей, старше 15 лет на корабле?

Источник данных: https://www.kaggle.com/c/titanic/data
"""

import pandas as pd
data = pd.read_csv('train.csv', index_col="PassengerId")
type (data)

# Задание #1
def get_sex_distrib(data) -> str:
    """
    1. Какое количество мужчин и женщин ехало на параходе? 
    
    Приведите два числа через пробел.
    """
    # data['Sex'].value_counts()
    n_male, n_female = data['Sex'].value_counts() # кол-во различных значений
    return f"{n_male}, {n_female}"

print(get_sex_distrib(data))

# Задание #2
# C = Cherbourg, Q = Queenstown, S = Southampton

def get_port_distrib(data) -> str:
    """  
    2. Подсчитайте сколько пассажиров загрузилось на борт в различных портах? 
    Приведите три числа через пробел.
    """

    port_S, port_C, port_Q = data['Embarked'].value_counts() # кол-во различных значений
    return f"{port_S}, {port_C}, {port_Q}"


print(get_port_distrib(data))

# Задание 3

def find_no_survived_percent(data):
    """
    3. Посчитайте долю (процент) погибших на параходе (число и процент)?
    """
    count = data['Survived'].value_counts(normalize=True) # кол-во различных значений (normalize показывает доли, т.к. проценты)
    return round(count.sort_index().values[0], 2) # округление до 2 знаков после запятой

print(find_no_survived_percent(data))

# Задание 4
def find_pclass_percents(data):
    """
    4. Какие доли составляли пассажиры первого, второго, третьего класса?
    """
    pclass_values = data['Pclass'].value_counts(normalize=True) # кол-во различных значений (normalize показывает доли, т.к. проценты)
    # возвращаются значения, отсортированные по возрастанию номера класса и округлённые до 2 знаков после запятой
    return tuple(map(lambda x: round(x, 2), pclass_values.sort_index().values))

print(find_pclass_percents(data))

# Задание 5
def find_corr_sibsp_parch(data):
    """
    5. Вычислите коэффициент корреляции Пирсона между количеством супругов (SibSp) и количеством детей (Parch).
    """
    sibsp = data['SibSp']
    parch = data['Parch']
    corr_val = sibsp.corr(parch) # корреляция между значениями двух столбцов
    return round(corr_val, 2)

print(find_corr_sibsp_parch(data))

# Задание 6

from numpy import isnan
# TODO #6-1
def find_corr_age_survival(data) -> float:
    """
    6. Выясните есть ли корреляция (вычислите коэффициент корреляции Пирсона) между:
    
    - возрастом и параметром Survived;

    """
    age = []
    surv = []
    i = 0
    # удаление значений NaN
    while i < len(data):

      if not(isnan(data.iloc[i]['Age'])):
        age.append(data.iloc[i]['Age'])
        surv.append(data.iloc[i]['Survived'])
      i+=1

    age, surv = pd.Series(age), pd.Series(surv)

    corr_val = age.corr(surv) # корреляция между значениями двух столбцов
    return round(corr_val, 2)


# TODO #6-2
def find_corr_sex_survival(data) -> float:
    """
    6. Выясните есть ли корреляция (вычислите коэффициент корреляции Пирсона) между:
    
    - полом человека и параметром Survived;
    """
    sex = []
    surv = []

    i = 0
    # удаление значений NaN
    while i < len(data):
        sex.append(1 if data.iloc[i]['Sex'] == 'male' else 0)
        surv.append(data.iloc[i]['Survived'])
        i += 1

    sex, surv = pd.Series(sex), pd.Series(surv)

    corr_val = sex.corr(surv) # корреляция между значениями двух столбцов
    return round(corr_val, 2)


# TODO #6-3
def find_corr_class_survival(data) -> float:
    """
    6. Выясните есть ли корреляция (вычислите коэффициент корреляции Пирсона) между:

    - классом, в котором пассажир ехал, и параметром Survived.
    """

    pclass = data['Pclass']
    surv = data['Survived']
    corr_val = pclass.corr(surv) # корреляция между значениями двух столбцов
    return round(corr_val, 2)


print(find_corr_age_survival(data))
print(find_corr_sex_survival(data))
print(find_corr_class_survival(data))

# Задание 7
def find_age_stats(data):
    """
    7. Посчитайте средний возраст пассажиров и медиану, минимальный и максимальный возраст.
    """
    stats = {}
    stats['mean'] = data['Age'].mean()
    stats['median'] = data['Age'].median()
    stats['min'] = data['Age'].min()
    stats['max'] = data['Age'].max()
    stats = {k: round(v, 2) for k, v in stats.items()} # округление до 2 знаков после запятой (генератор словарей)
    return stats

print(find_age_stats(data))

# Задание 8
def find_fare_stats(data):
    """
    8. Посчитайте среднюю цену за билет и медиану, минимальная и максимальные цены.
    """
    stats = {}
    stats['mean'] = data['Fare'].mean()
    stats['median'] = data['Fare'].median()
    stats['min'] = data['Fare'].min()
    stats['max'] = data['Fare'].max()
    stats = {k: round(v, 2) for k, v in stats.items()} # округление до 2 знаков после запятой (генератор словарей)
    return stats

print(find_fare_stats(data))

# Задание 9
def find_popular_name(data):
    """
    9. Какое самое популярное мужское имя на корабле?
    """
    names = data[['Name', 'Sex']] # выбор столбцов
    names = names.loc[names['Sex'] == 'male']['Name'] # выбор мужских имён
    # разбиваем строку по точке, и берём вторую часть (после точки)
    # т.е. удаляем фамилию и Mr.
    names = names.str.split('.', expand=True)[1]
    names = names.str.replace(r' \(.*\)', '', regex=True) # удаление скобок и текста в них
    names = names.str.replace(r' \".*\"', '', regex=True) # удаление кавычек и текста в них
    names = names.str.split(expand=True) # делим значения по пробелу (имён может быть несколько)
    names = pd.Series(names.values.reshape(-1)).dropna() # преобразование в один столбец и удаление значений NaN

    # по умолчанию значения расположены в порядке убывания, т.е. самое полулярное имя будет первым в списке
    most_popular_name = names.value_counts().keys()[0]

    return most_popular_name

print(find_popular_name(data))

# Задание 10

def find_popular_names(data):
    """
    10. Какие самые популярные мужское и женские имена людей, старше 15 лет на корабле?
    """
    names = data[['Name', 'Sex', 'Age']] # выбор столбцов
    names = names[names['Age'] >= 15] # выбор данных по возрасту
    male_names = names[names['Sex'] == 'male']['Name']  # выбор мужских имён
    female_names = names[names['Sex'] == 'female']['Name'] # выбор женских имён

    # разбиваем строку по точке, и берём вторую часть (после точки)
    # т.е. удаляем фамилию и Mr.
    male_names = male_names.str.split('.', expand=True)[1]
    male_names = male_names.str.replace(r' \(.*\)', '', regex=True) # удаление скобок и текста в них
    male_names = male_names.str.replace(r' \".*\"', '', regex=True) # удаление кавычек и текста в них
    male_names = male_names.str.split(expand=True) # делим значения по пробелу (имён может быть несколько)
    male_names = pd.Series(male_names.values.reshape(-1)).dropna() # преобразование в один столбец и удаление значений NaN

    # разбиваем строку по точке, и берём вторую часть (после точки)
    # т.е. удаляем фамилию и Mrs.
    female_names = female_names.str.split('.', expand=True)[1]
    female_names = female_names.str.replace('(', '', regex=False) # удаление скобок
    female_names = female_names.str.replace(')', '', regex=False) # но не текста в них, т.к. в скобках указаны женские имена
    female_names = female_names.str.replace(r' \".*\"', '', regex=True) # удаление кавычек и текста в них
    female_names = female_names.str.split(expand=True) # делим значения по пробелу (имён может быть несколько)
    female_names = pd.Series(female_names.values.reshape(-1)).dropna() # преобразование в один столбец и удаление значений NaN

    # по умолчанию значения расположены в порядке убывания, т.е. самое полулярное имя будет первым в списке
    most_popular_male_name = male_names.value_counts().keys()[0]
    most_popular_female_name = female_names.value_counts().keys()[0]

    most_popular_names = {'male': most_popular_male_name, 'female': most_popular_female_name}
    return most_popular_names

print(find_popular_names(data))